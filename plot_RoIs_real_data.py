#!/usr/bin/env python3

# Copyright (C) 2024 Andrea Raffo <andrea.raffo@ibv.uio.no>
#
# SPDX-License-Identifier: MIT


import argparse
import pathlib
import sys

import numpy as np
import pandas as pd

from utils import IO

# Resolution
resolution = 10000

# Output folder
output_path = pathlib.Path("./output/real data/RoIs/")


def parse_args():

    class CustomFormatter(argparse.RawTextHelpFormatter):
        def _fill_text(self, text, width, indent):
            return "".join([indent + line + "\n" for line in text.splitlines()])

    def _existing_file(arg: str) -> pathlib.Path:
        print(arg)
        if (path := pathlib.Path(arg)).is_file():
            return path

        raise FileNotFoundError(arg)

    def _existing_path(arg):
        path = pathlib.Path(arg)
        if path.exists() and path.is_dir():
            return path

        raise FileNotFoundError(f"Path not reachable: {path}")

    cli = argparse.ArgumentParser(
        description="Routine to plot StripePy, Chromosight, StripeCaller and Stripenn over real data. This "
        "script requires to download the following files and folders:\n"
        "• the real contact maps\n"
        "• the ChIP-seq peaks\n"
        "• StripePy's output folder\n"
        "• Chromosight's output folder\n"
        "• StripeCaller's output folder\n"
        "• Stripenn's output folder\n"
        "The location of the contact maps and ChIP-seq peaks are documented in the StripePy manuscript.\n"
        "The output folders of the stripe callers are here collected: https://zenodo.org/records/14449731.\n",
        formatter_class=CustomFormatter,
    )

    cli.add_argument(
        "contact-map",
        type=_existing_file,
        help="Path to an .mcool file for input (e.g., /tmp/ENCFF216QQM.fixed.mcool).",
    )

    cli.add_argument(
        "chip-seq-peaks",
        type=_existing_file,
        help="Path to the ChIP-seq peaks in .bed.gz format (e.g., /tmp/ENCFF796WRU.bed.gz).",
    )

    cli.add_argument(
        "--stripepy",
        type=_existing_path,
        required=True,
        help="Path to the folder containing the .hdf5 file generated by StripePy (e.g., /tmp/stripepy/real data/ENCFF216QQM.fixed).",
    )

    cli.add_argument(
        "--chromosight",
        type=_existing_path,
        required=True,
        help="Path to the folder containing the .tsv file generated by Chromosight (e.g., /tmp/chromosight/real data/ENCFF216QQM.fixed).",
    )

    cli.add_argument(
        "--stripecaller",
        type=_existing_path,
        required=True,
        help="Path to the folder containing the .BEDPE file generated by StripeCaller (e.g., /tmp/stripecaller/real data/ENCFF216QQM.fixed).",
    )

    cli.add_argument(
        "--stripenn",
        type=_existing_path,
        required=True,
        help="Path to the folder containing the .tsv file generated by Stripenn (e.g., /tmp/stripenn/real data/ENCFF216QQM.fixed).",
    )

    # Parse the input parameters:
    args = vars(cli.parse_args())

    # Gather input parameters in dictionaries:
    configs_input = {key: args[key] for key in ["contact-map", "chip-seq-peaks"]}
    configs_methods = {key: args[key] for key in ["stripepy", "chromosight", "stripecaller", "stripenn"]}

    # Print the used parameters (chosen or default-ones):
    print("\nArguments:")
    print(f"contact-map: {configs_input['contact-map']}")
    print(f"chip-seq: {configs_input['chip-seq-peaks']}")
    print(f"M1: {configs_methods['stripepy']}")
    print(f"M2: {configs_methods['chromosight']}")
    print(f"M3: {configs_methods['stripecaller']}")
    print(f"M4: {configs_methods['stripenn']}")

    return configs_input, configs_methods


if __name__ == "__main__":

    # Import parameters:
    configs_input, configs_methods = parse_args()

    # Data loading:
    c, chr_starts, chr_ends, bp_lengths = IO.cmap_loading(str(configs_input["contact-map"]), resolution)

    # RoI 1 (ENCFF993FGR.mcool)
    if configs_input["contact-map"].stem == "ENCFF993FGR":
        chromosome = "chr2"

        # RoI:
        RoI_length = int(2000000 / resolution)
        RoI_m = int((chr_ends[1] - chr_starts[1]) / 2)
        RoI_s = RoI_m - int(RoI_length / 2)
        RoI_e = RoI_m + int(RoI_length / 2)
        RoI = dict()
        RoI["matrix"] = [RoI_s, RoI_e, RoI_s, RoI_e]
        RoI["genomic"] = [int(roi * resolution) for roi in RoI["matrix"]]

    # RoI 2 (4DNFI6HDY7WZ.fixed.mcool)
    if configs_input["contact-map"].stem == "4DNFI6HDY7WZ.fixed":
        chromosome = "chr9"

        # RoI:
        RoI_length = int(2000000 / resolution)
        RoI_m = int((chr_ends[1] - chr_starts[1]) / 2)
        RoI_s = RoI_m - int(RoI_length / 2)
        RoI_e = RoI_m + int(RoI_length / 2)
        RoI = dict()
        RoI["matrix"] = [RoI_s, RoI_e, RoI_s, RoI_e]
        RoI["genomic"] = [int(roi * resolution) for roi in RoI["matrix"]]

    # RoI 3 (4DNFI9GMP2J8.fixed.mcool)
    if configs_input["contact-map"].stem == "4DNFI9GMP2J8.fixed":
        chromosome = "chr7"

        # RoI:
        RoI_length = int(2000000 / resolution)
        RoI_m = int((chr_ends[1] - chr_starts[1]) / 2)
        RoI_s = RoI_m - int(RoI_length / 2)
        RoI_e = RoI_m + int(RoI_length / 2)
        RoI = dict()
        RoI["matrix"] = [RoI_s, RoI_e, RoI_s, RoI_e]
        RoI["genomic"] = [int(roi * resolution) for roi in RoI["matrix"]]

    # RoI 4 (ENCFF216QQM.fixed)
    if configs_input["contact-map"].stem == "ENCFF216QQM.fixed":
        chromosome = "chr12"

        # RoI:
        RoI_length = int(2000000 / resolution)
        RoI_m = int((chr_ends[1] - chr_starts[1]) / 2)
        RoI_s = RoI_m - int(RoI_length / 2)
        RoI_e = RoI_m + int(RoI_length / 2)
        RoI = dict()
        RoI["matrix"] = [RoI_s, RoI_e, RoI_s, RoI_e]
        RoI["genomic"] = [int(roi * resolution) for roi in RoI["matrix"]]

    # Retrieve contact map:
    I = c.fetch(chromosome).to_coo().tolil()
    number_of_bins = I.shape[0]

    # Symmetrization:
    I += I.T
    I.setdiag(I.diagonal() / 2)
    I = I.tocsr()

    # Log-transform and standardization:
    Iproc = I.log1p()
    Iproc /= Iproc.max()

    # ChIP-seq peaks:
    header_names = ["chrom", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak"]
    df = pd.read_csv(configs_input["chip-seq-peaks"], compression="gzip", sep="\t", header=None, names=header_names)
    df["anchor"] = (df["start"] + df["end"]) / 2
    df = df.astype({"anchor": int})
    df = df[df["chrom"] == chromosome]

    # Ground-truth classification vector:
    GT_anchors = np.unique(np.round(df.anchor.values / resolution)).astype(int).tolist()

    # RoI extraction:
    rows = cols = slice(RoI["matrix"][0], RoI["matrix"][1])
    Iproc_RoI = Iproc[rows, cols].toarray()

    # Plot RoI:
    GT_anchors_in_RoI = [GT_anchor for GT_anchor in GT_anchors if RoI["matrix"][0] <= GT_anchor <= RoI["matrix"][1]]

    # Retrieve output of callers:
    path2M1 = configs_methods["stripepy"] / f"{resolution}" / ""
    path2M2 = configs_methods["chromosight"] / f"{resolution}" / ""
    path2M3 = configs_methods["stripecaller"] / f"{resolution}" / ""
    path2M4 = configs_methods["stripenn"] / f"{resolution}" / ""
    M1 = IO.retrieve_stripepy(path2M1, chromosome, number_of_bins, 5.0)
    M2 = IO.retrieve_chromosight(path2M2, chromosome, I.shape[0], resolution)
    M3 = IO.retrieve_stripecaller(path2M3, chromosome, I.shape[0], resolution)
    M4 = IO.retrieve_stripenn(path2M4, chromosome, I.shape[0], resolution, filter_=True)

    IO.plot_RoI_and_predictions(
        Iproc_RoI,
        RoI,
        resolution,
        [GT_anchors_in_RoI, GT_anchors_in_RoI],
        200000,
        M1=M1,
        plot_axis=False,
        output_path=output_path / f"{configs_input['contact-map'].stem}_M1.svg",
    )
    IO.plot_RoI_and_predictions(
        Iproc_RoI,
        RoI,
        resolution,
        [GT_anchors_in_RoI, GT_anchors_in_RoI],
        200000,
        M2=M2,
        M3=M3,
        plot_axis=False,
        output_path=output_path / f"{configs_input['contact-map'].stem}_M2M3.svg",
    )
    IO.plot_RoI_and_predictions(
        Iproc_RoI,
        RoI,
        resolution,
        [GT_anchors_in_RoI, GT_anchors_in_RoI],
        200000,
        M4=M4,
        plot_axis=False,
        output_path=output_path / f"{configs_input['contact-map'].stem}_M4.svg",
    )

    print("Done.")
