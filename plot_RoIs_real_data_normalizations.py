import argparse
import pathlib
import sys

import numpy as np
import pandas as pd

from utils import IO

# Resolution
resolution = 10000

# Output folder
output_path = pathlib.Path("./output/real data/RoIs/")


def parse_args():

    def _existing_path(arg):
        path = pathlib.Path(arg)
        if path.exists() and path.is_dir():
            return path

        raise FileNotFoundError(f"Path not reachable: {path}")

    def _existing_file(arg: str) -> pathlib.Path:
        print(arg)
        if (path := pathlib.Path(arg)).is_file():
            return path

        raise FileNotFoundError(arg)

    class CustomFormatter(argparse.RawTextHelpFormatter):
        def _fill_text(self, text, width, indent):
            return "".join([indent + line + "\n" for line in text.splitlines()])

    cli = argparse.ArgumentParser(
        description="Routine to plot RoIs of real contact maps with overimposed Stripper's predictions under "
        "different normalizations. This "
        "script requires to download the following files and folders:\n"
        "• the real contact maps\n"
        "• the ChIP-seq peaks\n"
        "• StripePy's output folder\n"
        "The location of the contact maps and ChIP-seq peaks are documented in the StripePy manuscript.\n"
        "The output folders of the stripe caller are here collected: https://zenodo.org/records/14449731.\n",
        formatter_class=CustomFormatter,
    )

    cli.add_argument(
        "contact-map",
        type=_existing_file,
        help="Path to an .mcool file for input (e.g., /tmp/4DNFI9GMP2J8.fixed.mcool).",
    )

    cli.add_argument(
        "chip-seq-peaks",
        type=_existing_file,
        help="Path to the ChIP-seq peaks in .bed.gz format (e.g., /tmp/ENCFF692RPA.bed.gz).",
    )

    cli.add_argument(
        "--stripepy",
        type=_existing_path,
        required=True,
        help="Path to the folder containing the .hdf5 file generated by StripePy (e.g., /tmp/stripepy/real data/"
        "4DNFI9GMP2J8.fixed).",
    )

    # Parse the input parameters:
    args = vars(cli.parse_args())

    # Gather input parameters in dictionaries:
    configs_input = {key: args[key] for key in ["contact-map", "chip-seq-peaks"]}
    configs_methods = {"stripepy": args["stripepy"]}

    # Print the used parameters (chosen or default-ones):
    print("\nArguments:")
    print(f"contact-map: {configs_input['contact-map']}")
    print(f"chip-seq: {configs_input['chip-seq-peaks']}")
    print(f"stripepy: {configs_methods['stripepy']}")

    return configs_input, configs_methods


if __name__ == "__main__":

    # Import parameters:
    configs_input, configs_methods = parse_args()

    # Data loading:
    c, chr_starts, chr_ends, bp_lengths = IO.cmap_loading(str(configs_input["contact-map"]), resolution)

    for normalization in ["NONE", "GW_ICE", "GW_SCALE"]:

        # ENCFF993FGR.mcool
        if configs_input["contact-map"].stem == "ENCFF993FGR":
            # Chosen chromosome number:
            chromosome = "chr2"

            # RoI:
            RoI_length = int(2000000 / resolution)
            RoI_m = int((chr_ends[1] - chr_starts[1]) / 2)
            RoI_s = RoI_m - int(RoI_length / 2)
            RoI_e = RoI_m + int(RoI_length / 2)
            RoI = dict()
            RoI["matrix"] = [RoI_s, RoI_e, RoI_s, RoI_e]
            RoI["genomic"] = [int(roi * resolution) for roi in RoI["matrix"]]

        # 4DNFI6HDY7WZ.fixed.mcool
        if configs_input["contact-map"].stem == "4DNFI6HDY7WZ.fixed":
            # Chosen chromosome number:
            chromosome = "chr9"

            # RoI:
            RoI_length = int(2000000 / resolution)
            RoI_m = int((chr_ends[1] - chr_starts[1]) / 2)
            RoI_s = RoI_m - int(RoI_length / 2)
            RoI_e = RoI_m + int(RoI_length / 2)
            RoI = dict()
            RoI["matrix"] = [RoI_s, RoI_e, RoI_s, RoI_e]
            RoI["genomic"] = [int(roi * resolution) for roi in RoI["matrix"]]

        # 4DNFI9GMP2J8.fixed.mcool
        if configs_input["contact-map"].stem == "4DNFI9GMP2J8.fixed":
            # Chosen chromosome number:
            chromosome = "chr7"

            # RoI:
            RoI_length = int(2000000 / resolution)
            RoI_m = int((chr_ends[1] - chr_starts[1]) / 2)
            # RoI_m = int(RoI_length/2)
            RoI_s = RoI_m - int(RoI_length / 2)
            RoI_e = RoI_m + int(RoI_length / 2)
            RoI = dict()
            RoI["matrix"] = [RoI_s, RoI_e, RoI_s, RoI_e]
            RoI["genomic"] = [int(roi * resolution) for roi in RoI["matrix"]]

        # ENCFF216QQM.fixed
        if configs_input["contact-map"].stem == "ENCFF216QQM.fixed":
            # Chosen chromosome number:
            chromosome = "chr12"

            # RoI:
            RoI_length = int(2000000 / resolution)
            RoI_m = int((chr_ends[1] - chr_starts[1]) / 2)
            RoI_s = RoI_m - int(RoI_length / 2)
            RoI_e = RoI_m + int(RoI_length / 2)
            RoI = dict()
            RoI["matrix"] = [RoI_s, RoI_e, RoI_s, RoI_e]
            RoI["genomic"] = [int(roi * resolution) for roi in RoI["matrix"]]

        # Retrieve contact map:
        I = c.fetch(chromosome, normalization=normalization).to_coo().tolil()
        number_of_bins = I.shape[0]

        # Symmetrization:
        I += I.T
        I.setdiag(I.diagonal() / 2)
        I = I.tocsr()

        # Log-transform and standardization:
        I.data[np.isnan(I.data)] = 0
        I.eliminate_zeros()
        Iproc = I.log1p()
        Iproc /= Iproc.max()

        # ChIP-seq peaks:
        header_names = ["chrom", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak"]
        df = pd.read_csv(configs_input["chip-seq-peaks"], compression="gzip", sep="\t", header=None, names=header_names)
        df["anchor"] = (df["start"] + df["end"]) / 2
        df = df.astype({"anchor": int})
        df = df[df["chrom"] == chromosome]

        # Ground-truth classification vector:
        GT_anchors = np.unique(np.round(df.anchor.values / resolution)).astype(int).tolist()

        # RoI extraction:
        rows = cols = slice(RoI["matrix"][0], RoI["matrix"][1])
        Iproc_RoI = Iproc[rows, cols].toarray()

        # Plot RoI:
        GT_anchors_in_RoI = [GT_anchor for GT_anchor in GT_anchors if RoI["matrix"][0] <= GT_anchor <= RoI["matrix"][1]]

        # Retrieve output of callers
        if normalization == "NONE":
            path2M1 = configs_methods["stripepy"] / f"{resolution}" / ""
        else:
            path2M1 = configs_methods["stripepy"] / f"{resolution}-{normalization}" / ""
        M1 = IO.retrieve_stripepy(path2M1, chromosome, number_of_bins, 5.0)

        IO.plot_RoI_and_predictions(
            Iproc_RoI,
            RoI,
            resolution,
            [GT_anchors_in_RoI, GT_anchors_in_RoI],
            200000,
            M1=M1,
            plot_axis=False,
            output_path=output_path / f"{configs_input['contact-map'].stem}-stripepy-{normalization}.svg",
        )

    print("Done.")
